<<Intro>>

안녕하세요, 추천 시스템을 도입하여 온라인 서점을 구현한 팀 4입니다.

저희는 문제를 정의한 뒤에 
바로 서브그룹 별로 나눠 설계를 시작하였습니다.
저희 팀은 Waterfall 방식을 사용했고, 
완벽한 설계를 위해 매 체크포인트마다 
줌이나 슬랙으로 여러번 회의를 진행하였습니다.
이때 회의에서는 다른 그룹의 역할을 침범하지 않고, 
유저 입장이 되어 꼼꼼히 피드백을 하였습니다.
이제 각 서브그룹 순서대로 발표하도록 하겠습니다.

<<Subgroup1>>

안녕하세요 서브그룹1 베이직팀입니다.
저희는 웹사이트 기본 인프라를 담당했습니다.

베이직 팀이 담당하는 기능은 총 10가지 정도로, 간단히 말하면 회원가입 및 로그인, 검색, 관리자 운영 기능 등 입니다. 

분석된 요구들 중에서 설계와 구현에 사용할 상위 30퍼센트 요구는 다음과 같고

이에 해당하는 use case는 총 6개입니다. 이 기능들은 사용자와 DB의 직접적 상호작용이라는 공통점이 있고 따라서 저희는 설계의 중심을 사용자와 DB 간의 정확한 정보교환에 두었습니다.

베이직 팀의 OSD는 사용자와 DB 사이에서 데이터가 어떻게 이동하는지를 주로 표현합니다. 또 다른 중요한 기능은 사용자의 권한 확인입니다. (클릭)
따라서 회원가입/로그인 시에 권한을 부여하고, 전체 시스템 내에서 권한 여부를 확인하는 concept로 Authorizer를 추가하였습니다.

설계 단계에서는 구현에 사용한 장고에 대한 이해가 부족했기 때문에 interface page에 대한 클래스 다이어그램을 생략했습니다.

저희는 회원가입 및 로그인 페이지, 책 검색 페이지, 책 정보 페이지, 그리고 관리자 페이지를 만들었습니다. 구현을 할 때 중점을 둔 부분은 요구가 결과물에 잘 반영되는가 였습니다.

먼저, 회원가입 및 로그인에 대한 요구를 구현한 메인페이지입니다.

다음은 로그인 후 검색창에 키워드 입력 시 나오는 페이지로, 검색에 대한 요구를 구현했습니다. 

목록에서 책 제목을 클릭하면 다음과 같이 상세 정보를 볼 수 있으며, 페이지에 있는 add to cart 버튼을 누르면 장바구니에 담겼다는 안내창이 나타납니다.

마지막으로, 메인페이지에서 admin으로 로그인하면 데이터베이스를 관리할 수 있는 장고 관리자 사이트로 이동합니다. 이 부분은 관리자 계정 생성과 책 DB 관리에 대한 요구를 구현하였습니다.
이것을 구현하는 과정에서 장고에서 기본적으로 지원하는 superuser 권한을 사용하여 보다 쉽게 구현이 가능하였습니다. 

<<Subgroup2>>

저는 결제 관련 시스템을 맡은 두번째 서브그룹이고, 
장바구니와 결제 과정 구현을 맡았습니다.
저희 그룹의 특이사항에 대해 말씀드리겠습니다.

먼저, RAD에서 요구사항을 정의할 때, 
requirements를 빠짐 없이 찾아내기 위해서 
각 상황에 따른 part를 (이렇게) 정리하였고, 
이에 따른 requirements를 표로 나타내었습니다.

Use Case Diagram을 그릴 때는 
저희의 모든 Use Case의 관계를 한방에 나타내지 않고, 
보다 쉽게 파악할 수 있도록 구체적인 세 개의 SubSystem으로 나누어 그렸습니다.

그 다음으로 SDD에서 Object Sequence Diagram과 Class Diagram을 그릴 때는 
저희가 찾은 모든 variation에 대한 장단점을 충분히 분석하여 
가장 적합하다고 생각하는 variation을 최종 선택하였습니다.

이 과정은 기존에 찾은 모든 요구사항에 대해서도 이루어졌을 뿐만 아니라, 
저희가 뽑은 이 상위 30%의 요구사항의 구현을 위해 
이에 대해서도 이루어져야 했습니다.

그래서 저희는 이러한 상위 30%의 요구사항에 따라 
이와 같이 Use Case를 재정의하였고, 
OSD와 CD 또한 다시 그렸습니다.

구현하는 과정에서는 
저희가 설계한 내용을 완전히 반영하려고 노력하였으나, 
django 프레임워크를 사용하게 되면서 
django에 내장된 기능과 html이 있어 
몇몇 Object를 만들지 않아도 되었습니다.
따라서 설계 그대로 코드를 작성하지 않은 부분이 있습니다.

이렇게 저희는 장바구니 페이지와

결제 정보 입력 페이지, 

결제 과정 페이지를 구현했습니다.

또한, 저희는 stand alone demo를 위해 
저희 서브그룹의 역할이 아닌 기능도 
이 메인 화면과 같이 간단히 구현해 놓았습니다.

한 가지 아쉬운 점이 있었다면, 앞서 결제 과정 페이지에서 
원래는 이 부분에 PG사에서 결제를 진행하는 부분이 들어가야 하지만, 
저희가 실제 기업이 아니기 때문에 가맹점 번호가 없어 
PG사를 연동하지 못했다는 것입니다.

<<Subgroup3>>

세번째 서브그룹은 도서를 추천하는 메인페이지를 담당했습니다. 저희는 고객에게 아이디어를 제안하는 것을 주의해야 하고, 일관성 있는 요구 도출의 중요성을 느꼈습니다. 
UI를 수집할 때, 고객에게 “추천된 책 관심없음 버튼”과 더 많은 책 디스플레이가 있으면 어떻게냐는 제안에 필요하지 않은 기능 같다는 답변을 받았고, 

결국 요구를 수정하게 되었습니다. (1초)

또한 내부 연관된 개념에서 고객의 정보보호 관련 비기능적 요소가 필요하였습니다. 따라서 저희 사이트의 휴면정책을 만들어 휴면계정의 log 기록을 익명화하여 관리하였습니다. 

저희는 SDD작성 시, 앞으로 프로젝트의 확장성을 고려하였습니다. 
이 사례는 Display UC 입니다. 기존 Controller에서는 조건문을 하나씩 비교해가며 버튼 처리를 하였는데, variation에서는 버튼 이벤트가 전달되면 ButtonCtrl와 ButtonKey가 어느 버튼인지를 판단한 후, Button Ctrl에서 기능을 수행합니다. 설계에서 기능의 분업과 응집도를 높인 덕에 구현을 할 때도, 버튼과 관련된 코드를 단번에 알 수 있어 수정하기 편했습니다. 

추천할 때 데이터의 로딩 시간이 가장 길 것이라고 판단해 sdd를 보면 update된 데이터가 있을 때만 로드합니다. 이후 추천 알고리즘의 로딩 시간을 줄이는 설계가 더 필요했습니다. 
저희는 사용자 맞춤 collaborative filtering중에서 행렬 분해를 적용하여 추천하는데, 이는 데이터 압축의 효과를 볼 수 있지만, 실제로는 데이터 로드 보다 실행 시간이 더 길었기 때문입니다. 

구현은 데이터를 파일로 연결하여 추천이 동작하는 것 같은 상태에서, DB를 연결하여 완성하였습니다. 그리고 이미지 파일로 대체했던 html을 진짜 추천 목록과 연결하였습니다. 

 다음은 Requirement 상황에 따라 추천 도서가 업데이트되는 모습입니다. 이때 서브그룹 1의 login파트에서 고객 ID를 넘겨주는 부분을 가상의 서버를 사용해 전달합니다.

이외에 stand alone한 개발을 위해 검색페이지와 책 상세페이지로의 redirect시 고객 로그를 생성하는 페이지 모듈을 사용했습니다. 

<<Outro>>

이상 팀 4 발표 마치겠습니다 질문 있으신 분 해주시면 감사하겠습니다